class Solution {
public:
    int n;
    vector<vector<int>> overlap_dist;
    unordered_map<int, unordered_map<int, string>> memo;

    // Returns the number of overlapping characters from suffix of a and prefix of b
    int overlap(string& a, string& b) {
        int max_len = min(a.size(), b.size());
        for (int len = max_len; len > 0; --len) {
            if (a.substr(a.size() - len) == b.substr(0, len))
                return len;
        }
        return 0;
    }

    string dp(int last, int mask, vector<string>& words) {
        if (mask == (1 << n) - 1)
            return words[last];

        if (memo[last].count(mask))
            return memo[last][mask];

        string res = string(1000, 'x'); // large string placeholder

        for (int next = 0; next < n; ++next) {
            if (!(mask & (1 << next))) {
                int ov = overlap_dist[last][next];
                string temp = dp(next, mask | (1 << next), words);
                string combined = words[last] + temp.substr(ov);

                if (combined.length() < res.length())
                    res = combined;
            }
        }

        return memo[last][mask] = res;
    }

    string shortestSuperstring(vector<string>& words) {
        n = words.size();
        overlap_dist = vector<vector<int>>(n, vector<int>(n, 0));

        // Build overlap matrix
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (i != j)
                    overlap_dist[i][j] = overlap(words[i], words[j]);

        string ans = string(1000, 'x');
        for (int i = 0; i < n; ++i) {
            string candidate = dp(i, 1 << i, words);
            if (candidate.length() < ans.length())
                ans = candidate;
        }

        return ans;
    }
};
